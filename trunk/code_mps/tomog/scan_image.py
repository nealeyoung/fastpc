import Image
import math
import sys
import os

"""Take a bitmap image and extract one-dimensional projections from it.
   Consider each pixel as a variable, scanning L to R and top to bottom.
   Projections are generated from density slices through the image
   at various angles.
"""


def gen_row(angle,x,y,step,array,region,bound ):
    """Each slice is generated by sampling the pixel value at regular intervals
   along the slice line.
   """

    distance = 0
    total_density = 0
    variable_track = []  # list of sampled boxes (pixels) and number of times they were sampled
    last_x = -1  # most recent x-coord of box (pixel)
    last_y = -1  #  "     "    y-coord "   "     "
    
    while(True):
        distance = distance + step
        cur_x = int(math.floor(distance * math.cos(angle) + x ))
        cur_y = int(bound(distance * math.sin(angle) + y))

        if cur_x >  region.size[0]-1 or cur_y > region.size[1]-1 or cur_x < 0 or cur_y <0:
            break    # off the edge of the bitmap
        total_density = array[cur_y][cur_x] + total_density
        if(cur_x == last_x and cur_y ==last_y): # this sample is still in same box (pixel) as last sample
            variable_track[-1][1] = variable_track[-1][1] + 1 
        else:  # into new box (pixel)
            variable_track.append([cur_y*region.size[0]+cur_x,1])
            last_x = cur_x
            last_y = cur_y
    return variable_track, total_density

args = sys.argv
if len(args) < 2:
    print 'Usage: python run_test.py <image_name>'
    sys.exit(0)
img_name = args[1]
img_name_no_ext = img_name[:img_name.find('.')]
out_file_name = 'fastpc_input_' + img_name_no_ext

im = Image.open(img_name)
box = (0, 100, 80, 180)
converted = im.convert('L').crop(box)
converted.show()
converted.save(img_name_no_ext + '_converted.png')

print converted.size[0]  # width
print converted.size[1]  # height

data= list(converted.getdata())
array = []  # stores bitmap as 2d array row by row; [0][0] is top-left corner
for i in range(0,len(data),converted.size[1]):
    array.append(data[i:i+converted.size[1]])

my_file = open(out_file_name,'w')

non_zeros = 0
rows = 0

#change angle down from left 
for i in range(0,converted.size[1],1): #number of slices per angle
    for j in range(-90,90,2):  #angles
        rows = rows + 1
        equ_array,t_size = gen_row(j*math.pi/180 , 0.0, i, 0.01, array,converted,math.floor)

         #only write nonzeros if variables exist and density is > 0    
        if len(equ_array)<1 or t_size==0:
            rows =  rows -1
            continue
        for item in equ_array:
            my_file.write(str(rows-1) + ' ' + str(item[0]) + ' ' + str(float(item[1])/float(t_size)) + '\n')
            non_zeros = non_zeros + 1

#change angle up from right
for i in range(0,converted.size[1],1):
    for j in range(90,270,2):
        rows = rows + 1
        equ_array,t_size = gen_row(j*math.pi/180 , converted.size[0], i, 0.01, array,converted,math.floor)
        if len(equ_array)<1 or t_size==0:
            rows =  rows -1
            continue
        for item in equ_array:
            my_file.write(str(rows-1) + ' ' + str(item[0]) + ' ' + str(float(item[1])/float(t_size)) + '\n')
            non_zeros = non_zeros + 1

#change angle from top
print "In change angle from top"  #debug
for i in range(0,converted.size[0],1):
   # for j in map(lambda a: a*-1,range(0,180,2)):
   for j in range(0,180,2):
        rows = rows + 1
        equ_array,t_size = gen_row(j*math.pi/180 , i,0.0, 0.01, array,converted,math.floor)
        if len(equ_array)<1 or t_size==0:
            rows = rows -1
            continue
        #print "Column:", i, "Angle:", j, "Length of equ_array:", len(equ_array), "T size:", t_size #debug
        for item in equ_array:
            my_file.write(str(rows-1) + ' ' + str(item[0]) + ' ' + str(float(item[1])/float(t_size)) + '\n')
            non_zeros = non_zeros + 1

#change angle from bottom
for i in range(0,converted.size[0],1):
    for j in map(lambda a: a*-1,range(0,180,2)):
        rows = rows + 1
        equ_array,t_size = gen_row(j*math.pi/180 , i,converted.size[1], 0.01, array,converted,math.floor)
        if len(equ_array)<1 or t_size==0:
            rows = rows -1
            continue
        for item in equ_array:
            my_file.write(str(rows-1) + ' ' + str(item[0]) + ' ' + str(float(item[1])/float(t_size)) + '\n')
            non_zeros = non_zeros + 1

#commented this because now we are scaling the solution to have values bounded in fastpc
#keep in color bounds
#for var in range(converted.size[1]*converted.size[0]):
#    rows = rows + 1
#    my_file.write(str(rows-1) + ' ' + str(var) + ' ' + str(1.0/255.0) + '\n')
#    non_zeros = non_zeros + 1
    
my_file.close()

#prepend first line of output file showing rows, cols, nonzeros
cmd = "sed -i '1i\\" + str( rows) +' ' + str(converted.size[1]*converted.size[0])+ ' ' + str(non_zeros) + "' " + out_file_name
os.system(cmd)
